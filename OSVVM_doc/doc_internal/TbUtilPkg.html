
<style>
  table {
    width:70%;
    margin-left: auto;
    margin-right: auto
  }
  svg {
    width:68%;
    height:30%;
    display:block;  
    margin-left: auto;
    margin-right: auto
  }
  h1, h2, h3, h4 {
    margin-left:1.5%;
    width:98%;
    font-weight:bold
  }
  code {
    color:#545253;
  }
  p {
    width: 98%;
    color:black;
    margin-top:5px;
    margin-bottom:5px 
  }
  * {
    color:black;
    line-height: 1.6;
  }
  li{
    margin: 20px 0;
  }
  #function_return{
    font-weight: bold;
    color:green;
  }
  #teroshdl_description, li {
    width: 95%;
    margin-left:2%;
    margin-right:2%;
  }
  #function_arguments{
    color:black;
  }
  #descriptions{
    width: 90%;
    margin-left:5.5%;
    margin-right:3%;
  }
  div.templateTerosHDL {
    background-color: white;
    position:absolute;
  }
  td, th {
    padding:2px; 
    border: 1px solid grey;
  }
  th {
    background-color: #ffd78c;
  }
  tr:hover {
    background-color: #ddd;
  }
  tr:nth-child(even){
    background-color: #f2f2f2;
  }
</style>
<div id="teroshdl" class='templateTerosHDL'>
<a id=TbUtilPkg><h1 id="package-tbutilpkg">Package: TbUtilPkg</h1></a><h2 id="constants">Constants</h2>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="value">Value</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLK_ACTIVE</td>
<td>std_logic</td>
<td>'1'</td>
<td></td>
</tr>
<tr>
<td>t_sim_resolution</td>
<td>time</td>
<td>std.env.resolution_limit</td>
<td>VHDL-2008</td>
</tr>
</tbody>
</table><h2 id="functions">Functions</h2><ul>
<li>OneHot <font id="function_arguments">( constant A : in std_logic_vector ) </font> <font id="function_return">return boolean </font></li>
</ul><ul>
<li>ZeroOneHot <font id="function_arguments">( constant A : in std_logic_vector ) </font> <font id="function_return">return boolean </font></li>
</ul><ul>
<li>IfElse <font id="function_arguments">(Expr : boolean ; A, B : std_logic_vector) </font> <font id="function_return">return std_logic_vector </font></li>
</ul><ul>
<li>IfElse <font id="function_arguments">(Expr : boolean ; A, B : integer) </font> <font id="function_return">return integer </font></li>
</ul><ul>
<li>RequestTransaction <font id="function_arguments">( signal Rdy  : Out std_logic ; signal Ack  : In  std_logic ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>WaitForTransaction <font id="function_arguments">( signal Clk  : In  std_logic ; signal Rdy  : In  std_logic ; signal Ack  : Out std_logic ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>RequestTransaction <font id="function_arguments">( signal Rdy  : Out bit ; signal Ack  : In  bit ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>WaitForTransaction <font id="function_arguments">( signal Clk  : In  std_logic ; signal Rdy  : In  bit ; signal Ack  : Out bit ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>RequestTransaction <font id="function_arguments">( signal Rdy     : InOut RdyType ; signal Ack     : In    AckType ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>WaitForTransaction <font id="function_arguments">( signal Clk      : In    std_logic ; signal Rdy      : In    RdyType ; signal Ack      : InOut AckType ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>WaitForTransaction <font id="function_arguments">( signal   Clk       : In  std_logic ; signal   Rdy       : In  std_logic ; signal   Ack       : Out std_logic ; signal   TimeOut   : In  std_logic ; constant Polarity  : In  std_logic := '1' ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>WaitForTransactionOrIrq <font id="function_arguments">( signal Clk     : In  std_logic ; signal Rdy     : In  std_logic ; signal IntReq  : In  std_logic ) </font> <font id="function_return">return ()</font></li>
</ul><div id="descriptions"><p><strong>Description</strong><br />
Variation for model that stops waiting when IntReq is asserted<br />
Intended for models that need to switch between instruction streams<br />
such as a CPU when interrupt is pending</p></div><ul>
<li>StartTransaction <font id="function_arguments">( signal Ack : Out std_logic ) </font> <font id="function_return">return ()</font></li>
</ul><div id="descriptions"><p><strong>Description</strong><br />
Set Ack to Model starting value</p></div><ul>
<li>FinishTransaction <font id="function_arguments">( signal Ack : Out std_logic ) </font> <font id="function_return">return ()</font></li>
</ul><div id="descriptions"><p><strong>Description</strong><br />
Set Ack to Model finishing value</p></div><ul>
<li>TransactionPending <font id="function_arguments">( signal Rdy : In  std_logic ) </font> <font id="function_return">return boolean </font></li>
</ul><div id="descriptions"><p><strong>Description</strong><br />
If a transaction is pending, return true</p></div><ul>
<li>WaitForTransaction <font id="function_arguments">( signal Rdy : In  std_logic ; signal Ack : Out std_logic ) </font> <font id="function_return">return ()</font></li>
</ul><div id="descriptions"><p><strong>Description</strong><br />
Variation for clockless models</p></div><ul>
<li>Toggle <font id="function_arguments">( signal Sig        : InOut std_logic ; constant DelayVal : time ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>Toggle <font id="function_arguments">( signal Sig : InOut std_logic ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>ToggleHS <font id="function_arguments">( signal Sig : InOut std_logic ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>IsToggle <font id="function_arguments">( signal Sig : In std_logic ) </font> <font id="function_return">return boolean </font></li>
</ul><ul>
<li>WaitForToggle <font id="function_arguments">( signal Sig : In std_logic ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>Toggle <font id="function_arguments">( signal Sig : InOut bit ; constant DelayVal : time ) </font> <font id="function_return">return ()</font></li>
</ul><div id="descriptions"><p><strong>Description</strong><br />
Bit type versions</p></div><ul>
<li>Toggle <font id="function_arguments">( signal Sig : InOut bit ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>ToggleHS <font id="function_arguments">( signal Sig : InOut bit ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>IsToggle <font id="function_arguments">( signal Sig : In bit ) </font> <font id="function_return">return boolean </font></li>
</ul><ul>
<li>WaitForToggle <font id="function_arguments">( signal Sig : In bit ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>Increment <font id="function_arguments">( signal Sig : InOut integer ; constant RollOverValue : in integer := 0) </font> <font id="function_return">return ()</font></li>
</ul><div id="descriptions"><p><strong>Description</strong><br />
Integer type versions</p></div><ul>
<li>Increment <font id="function_arguments">(constant Sig : in integer ; constant Amount : in integer := 1) </font> <font id="function_return">return integer </font></li>
</ul><ul>
<li>WaitForToggle <font id="function_arguments">( signal Sig : In integer ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>WaitForBarrier <font id="function_arguments">( signal Sig : InOut std_logic ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>WaitForBarrier <font id="function_arguments">( signal Sig : InOut std_logic ; signal TimeOut : std_logic ; constant Polarity : in std_logic := '1') </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>WaitForBarrier <font id="function_arguments">( signal Sig : InOut std_logic ; constant TimeOut : time ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>resolved_barrier <font id="function_arguments">( s : integer_vector ) </font> <font id="function_return">return integer </font></li>
</ul><div id="descriptions"><p><strong>Description</strong><br />
resolved_barrier : summing resolution used in conjunction with integer based barriers</p></div><ul>
<li>WaitForBarrier <font id="function_arguments">( signal Sig : InOut integer ) </font> <font id="function_return">return ()</font></li>
</ul><div id="descriptions"><p><strong>Description</strong><br />
Usage of integer barriers requires resolved_barrier. Initialization to 1 recommended, but not required<br />
  signal barrier1 : resolved_barrier integer := 1 ;     -- using the resolution function<br />
  signal barrier2 : integer_barrier := 1 ;              -- using the subtype that already applies the resolution function</p></div><ul>
<li>WaitForBarrier <font id="function_arguments">( signal Sig : InOut integer ; signal TimeOut : std_logic ; constant Polarity : in std_logic := '1') </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>WaitForBarrier <font id="function_arguments">( signal Sig : InOut integer ; constant TimeOut : time ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>WaitForBarrier2 <font id="function_arguments">( signal SyncOut : out std_logic ; signal SyncIn : in  std_logic ) </font> <font id="function_return">return ()</font></li>
</ul><div id="descriptions"><p><strong>Description</strong><br />
Using separate signals</p></div><ul>
<li>WaitForBarrier2 <font id="function_arguments">( signal SyncOut : out std_logic ; signal SyncInV : in  std_logic_vector ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>WaitForClock <font id="function_arguments">( signal Clk : in std_logic ;  constant Delay : in time ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>WaitForClock <font id="function_arguments">( signal Clk : in std_logic ;  constant NumberOfClocks : in integer := 1) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>WaitForClock <font id="function_arguments">( signal Clk : in std_logic ;  signal Enable : in boolean ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>WaitForClock <font id="function_arguments">( signal Clk : in std_logic ;  signal Enable : in std_logic ; constant Polarity : std_logic := '1' ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>WaitForLevel <font id="function_arguments">( signal A : in boolean ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>WaitForLevel <font id="function_arguments">( signal A : in std_logic ; Polarity : std_logic := '1' ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>CreateClock <font id="function_arguments">( signal   Clk        : inout std_logic ; constant Period     : time ; constant DutyCycle  : real := 0.5 ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>CheckClockPeriod <font id="function_arguments">( constant AlertLogID : AlertLogIDType ; signal   Clk        : in  std_logic ; constant Period     : time ; constant ClkName    : string := "Clock" ; constant HowMany    : integer := 5 ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>CheckClockPeriod <font id="function_arguments">( signal   Clk        : in  std_logic ; constant Period     : time ; constant ClkName    : string := "Clock" ; constant HowMany    : integer := 5 ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>CreateReset <font id="function_arguments">( signal   Reset       : out std_logic ; constant ResetActive : in  std_logic ; signal   Clk         : in  std_logic ; constant Period      :     time ; constant tpd         :     time ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>LogReset <font id="function_arguments">( constant AlertLogID  : AlertLogIDType ; signal   Reset       : in  std_logic ; constant ResetActive : in  std_logic ; constant ResetName   : in  string := "Reset" ; constant LogLevel    : in  LogType := ALWAYS ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>LogReset <font id="function_arguments">( signal   Reset       : in  std_logic ; constant ResetActive : in  std_logic ; constant ResetName   : in  string := "Reset" ; constant LogLevel    : in  LogType := ALWAYS ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>WaitForAck <font id="function_arguments">( signal Ack : In  std_logic ) </font> <font id="function_return">return ()</font></li>
</ul><ul>
<li>StrobeAck <font id="function_arguments">( signal Ack : Out std_logic ) </font> <font id="function_return">return ()</font></li>
</ul><br><br><br><br><br><br>