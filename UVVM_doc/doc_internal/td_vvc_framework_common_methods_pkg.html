
<style>
  table {
    width:70%;
    margin-left: auto;
    margin-right: auto
  }
  svg {
    display:block;  
    width:60%;
    height:40%;
    margin-left: auto;
    margin-right: auto
  }
  h1, h2, h3 {
    margin-left:1.5%;
    width:98%;
    font-weight:bold
  }
  code {
    color:#545253;
  }
  p {
    width: 98%;
    color:black;
    margin-top:5px;
    margin-bottom:5px 
  }
  * {
    color:black;
    line-height: 1.6;
  }
  li{
    margin: 20px 0;
  }
  #function_return{
    font-weight: bold;
    color:green;
  }
  #teroshdl_description, li {
    width: 98%;
    margin-left:2%;
    margin-right:2%;
  }
  #function_arguments{
    color:blue;
  }
  div.templateTerosHDL {
    background-color: white;
    position:absolute;
  }
  td, th {
    padding:7px; 
    border: 1px solid grey;
  }
  th {
    background-color: #ffd78c;
  }
  tr:hover {
    background-color: #ddd;
  }
  tr:nth-child(even){
    background-color: #f2f2f2;
  }
</style>
<div id="teroshdl" class='templateTerosHDL'>
<a id=td_vvc_framework_common_methods_pkg><h1 id="package-td_vvc_framework_common_methods_pkg">Package: td_vvc_framework_common_methods_pkg</h1></a><h2 id="functions">Functions</h2>
<ul>
<li>await_completion <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant vvc_channel               : in    t_channel;
constant timeout                   : in    time;
constant msg                       : in    string         := "";
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font></li>
<li>await_completion <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant timeout                   : in    time;
constant msg                       : in    string         := "";
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
See description above</li>
<li>await_completion <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant vvc_channel               : in    t_channel;
constant wanted_idx                : in    integer;
constant timeout                   : in    time;
constant msg                       : in    string         := "";
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
VVC interpreter IMMEDIATE command- Awaits completion of the specified command 'wanted_idx' in the queue for the specified VVC, or  until timeout.</li>
<li>await_completion <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant wanted_idx                : in    integer;
constant timeout                   : in    time;
constant msg                       : in    string         := "";
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
See description above</li>
<li>await_any_completion <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant vvc_channel               : in    t_channel;
constant lastness                  : in    t_lastness;
constant timeout                   : in    time           := 100 ns;
constant msg                       : in    string         := "";
constant awaiting_completion_idx   : in    natural        := 0;
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
VVC interpreter IMMEDIATE command- Waits for the first of multiple VVCs to finish :  - Awaits completion of all commands in the queue for the specified VVC, or  - until global_awaiting_completion /= '1' (any of the other involved VVCs completed).</li>
<li>await_any_completion <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant lastness                  : in    t_lastness;
constant timeout                   : in    time           := 100 ns;
constant msg                       : in    string         := "";
constant awaiting_completion_idx   : in    natural        := 0;
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
Overload without vvc_channel</li>
<li>await_any_completion <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant vvc_channel               : in    t_channel;
constant wanted_idx                : in    integer;
constant lastness                  : in    t_lastness;
constant timeout                   : in    time           := 100 ns;
constant msg                       : in    string         := "";
constant awaiting_completion_idx   : in    natural        := 0;
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
Overload with wanted_idx- Awaits completion of the specified command 'wanted_idx' in the queue for the specified VVC, or  - until global_awaiting_completion /= '1' (any of the other involved VVCs completed).</li>
<li>await_any_completion <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant wanted_idx                : in    integer;
constant lastness                  : in    t_lastness;
constant timeout                   : in    time           := 100 ns;
constant msg                       : in    string         := "";
constant awaiting_completion_idx   : in    natural        := 0;
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
Overload without vvc_channel</li>
<li>disable_log_msg <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant vvc_channel               : in    t_channel;
constant msg_id                    : in    t_msg_id;
constant msg                       : in    string         := "";
constant quietness                 : in    t_quietness    := NON_QUIET;
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
VVC interpreter IMMEDIATE command- Disables the specified msg_id for the VVC</li>
<li>disable_log_msg <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant msg_id                    : in    t_msg_id;
constant msg                       : in    string         := "";
constant quietness                 : in    t_quietness    := NON_QUIET;
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
See description above</li>
<li>enable_log_msg <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant vvc_channel               : in    t_channel;
constant msg_id                    : in    t_msg_id;
constant msg                       : in    string         := "";
constant quietness                 : in    t_quietness    := NON_QUIET;
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
VVC interpreter IMMEDIATE command- Enables the specified msg_id for the VVC</li>
<li>enable_log_msg <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant msg_id                    : in    t_msg_id;
constant msg                       : in    string         := "";
constant quietness                 : in    t_quietness    := NON_QUIET;
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
See description above</li>
<li>flush_command_queue <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant vvc_channel               : in    t_channel;
constant msg                       : in    string         := "";
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
VVC interpreter IMMEDIATE command- Flushes the command queue of the specified VVC</li>
<li>flush_command_queue <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant msg                       : in    string         := "";
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
See description above</li>
<li>fetch_result <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant vvc_channel               : in    t_channel;
constant wanted_idx                : in    integer;
variable result                    : out   t_vvc_result;
variable fetch_is_accepted         : out   boolean;
constant msg                       : in    string         := "";
constant alert_level               : in    t_alert_level  := TB_ERROR;
constant caller_name               : in    string         := "base_procedure";
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
VVC interpreter IMMEDIATE command- Fetches result from a VVC- Requires that result is available (i.e. already executed in respective VVC)- Logs with ID ID_UVVM_CMD_RESULTThe 'result' parameter is of type t_vvc_result tosupport that the BFM returns something other than a std_logic_vector.</li>
<li>fetch_result <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant vvc_channel               : in    t_channel;
constant wanted_idx                : in    integer;
variable result                    : out   t_vvc_result;
constant msg                       : in    string         := "";
constant alert_level               : in    t_alert_level  := TB_ERROR;
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
-- Same as above but without fetch_is_accepted.-- Will trigger alert with alert_level if not OK.</li>
<li>fetch_result <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant wanted_idx                : in    integer;
variable result                    : out   t_vvc_result;
variable fetch_is_accepted         : out   boolean;
constant msg                       : in    string         := "";
constant alert_level               : in    t_alert_level  := TB_ERROR;
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
-- - This version does not use vvc_channel.-- - Fetches result from a VVC-- - Requires that result is available (i.e. already executed in respective VVC)-- - Logs with ID ID_UVVM_CMD_RESULT</li>
<li>fetch_result <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant wanted_idx                : in    integer;
variable result                    : out   t_vvc_result;
constant msg                       : in    string         := "";
constant alert_level               : in    t_alert_level  := TB_ERROR;
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
-- Same as above but without fetch_is_accepted.-- Will trigger alert with alert_level if not OK.</li>
<li>insert_delay <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant vvc_channel               : in    t_channel;
constant delay                     : in    natural;   in clock cycles
constant msg                       : in    string         := "";
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
VVC executor QUEUED command- Inserts delay for 'delay' clock cycles</li>
<li>insert_delay <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant delay                     : in    natural;   in clock cycles
constant msg                       : in    string         := "";
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
See description above</li>
<li>insert_delay <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant vvc_channel               : in    t_channel;
constant delay                     : in    time;
constant msg                       : in    string         := "";
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
VVC executor QUEUED command- Inserts delay for a given time</li>
<li>insert_delay <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant delay                     : in    time;
constant msg                       : in    string         := "";
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
See description above</li>
<li>terminate_current_command <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant vvc_channel               : in    t_channel      := NA;
constant msg                       : in    string         := "";
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
VVC interpreter IMMEDIATE command- Terminates the current command being processed in the VVC executor</li>
<li>terminate_current_command <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant msg                       : in    string         := "";
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
Overload without VVC channel</li>
<li>terminate_all_commands <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant vvc_channel               : in    t_channel      := NA;
constant msg                       : in    string         := "";
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
VVC interpreter IMMEDIATE command- Terminates the current command being processed in the VVC executor, and  flushes the command queue</li>
<li>terminate_all_commands <font id="function_arguments">(    signal   vvc_target                : inout t_vvc_target_record;
constant vvc_instance_idx          : in    integer;
constant msg                       : in    string         := "";
constant scope                     : in    string         := C_VVC_CMD_SCOPE_DEFAULT;
constant parent_msg_id_panel       : in    t_msg_id_panel := shared_msg_id_panel UVVM: temporary fix for HVVC, replace for C_UNUSED_MSG_ID_PANEL in v3.0
)</font> <font id="function_return">return ()</font><br />
<strong>Description</strong><br />
Overload without VVC channel</li>
</ul><br><br><br><br><br><br>