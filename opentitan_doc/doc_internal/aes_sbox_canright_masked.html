
<style>
  table {
    width:70%;
    margin-left: auto;
    margin-right: auto
  }
  svg {
    display:block;  
    width:60%;
    height:40%;
    margin-left: auto;
    margin-right: auto
  }
  h1, h2, h3 {
    margin-left:1.5%;
    width:98%;
    font-weight:bold
  }
  code {
    color:#545253;
  }
  p {
    width: 98%;
    color:black;
    margin-top:5px;
    margin-bottom:5px 
  }
  * {
    color:black;
    line-height: 1.6;
  }
  li{
    margin: 20px 0;
  }
  #function_return{
    font-weight: bold;
    color:green;
  }
  #teroshdl_description, li {
    width: 98%;
    margin-left:2%;
    margin-right:2%;
  }
  #function_arguments{
    color:blue;
  }
  div.templateTerosHDL {
    background-color: white;
    position:absolute;
  }
  td, th {
    padding:7px; 
    border: 1px solid grey;
  }
  th {
    background-color: #ffd78c;
  }
  tr:hover {
    background-color: #ddd;
  }
  tr:nth-child(even){
    background-color: #f2f2f2;
  }
</style>
<div id="teroshdl" class='templateTerosHDL'>
<a id=aes_masked_inverse_gf2p4><h1 id="entity-aes_masked_inverse_gf2p4">Entity: aes_masked_inverse_gf2p4</h1></a><h2 id="diagram">Diagram</h2><p><svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs" viewBox="0 0 355 110"><svg id="SvgjsSvg1002" width="2" height="0" focusable="false" style="overflow:hidden;top:-100%;left:-100%;position:absolute;opacity:0"><polyline id="SvgjsPolyline1003" points="95,0 110,0"></polyline><path id="SvgjsPath1004" d="M0 0 "></path></svg><rect id="SvgjsRect1006" width="150" height="90" fill="black" x="110" y="15"></rect><rect id="SvgjsRect1007" width="146" height="85" fill="#fdfd96" x="112" y="17"></rect><text id="SvgjsText1008" font-family="Helvetica" x="90" y="9.3015625" font-size="20" text-anchor="end" family="Helvetica" size="20" anchor="end" svgjs:data="{&quot;leading&quot;:&quot;1.3&quot;}"><tspan id="SvgjsTspan1009" dy="26" x="90" svgjs:data="{&quot;newLined&quot;:true}">   [3:0] </tspan></text><text id="SvgjsText1010" font-family="Helvetica" x="125" y="9.3015625" font-size="20" text-anchor="start" family="Helvetica" size="20" anchor="start" svgjs:data="{&quot;leading&quot;:&quot;1.3&quot;}"><tspan id="SvgjsTspan1011" dy="26" x="125" svgjs:data="{&quot;newLined&quot;:true}">   b </tspan></text><line id="SvgjsLine1012" x1="95" y1="30" x2="110" y2="30" stroke-linecap="rec" stroke="black" stroke-width="5"></line><text id="SvgjsText1013" font-family="Helvetica" x="90" y="29.3015625" font-size="20" text-anchor="end" family="Helvetica" size="20" anchor="end" svgjs:data="{&quot;leading&quot;:&quot;1.3&quot;}"><tspan id="SvgjsTspan1014" dy="26" x="90" svgjs:data="{&quot;newLined&quot;:true}">   [3:0] </tspan></text><text id="SvgjsText1015" font-family="Helvetica" x="125" y="29.3015625" font-size="20" text-anchor="start" family="Helvetica" size="20" anchor="start" svgjs:data="{&quot;leading&quot;:&quot;1.3&quot;}"><tspan id="SvgjsTspan1016" dy="26" x="125" svgjs:data="{&quot;newLined&quot;:true}">   q </tspan></text><line id="SvgjsLine1017" x1="95" y1="50" x2="110" y2="50" stroke-linecap="rec" stroke="black" stroke-width="5"></line><text id="SvgjsText1018" font-family="Helvetica" x="90" y="49.3015625" font-size="20" text-anchor="end" family="Helvetica" size="20" anchor="end" svgjs:data="{&quot;leading&quot;:&quot;1.3&quot;}"><tspan id="SvgjsTspan1019" dy="26" x="90" svgjs:data="{&quot;newLined&quot;:true}">   [1:0] </tspan></text><text id="SvgjsText1020" font-family="Helvetica" x="125" y="49.3015625" font-size="20" text-anchor="start" family="Helvetica" size="20" anchor="start" svgjs:data="{&quot;leading&quot;:&quot;1.3&quot;}"><tspan id="SvgjsTspan1021" dy="26" x="125" svgjs:data="{&quot;newLined&quot;:true}">   r </tspan></text><line id="SvgjsLine1022" x1="95" y1="70" x2="110" y2="70" stroke-linecap="rec" stroke="black" stroke-width="5"></line><text id="SvgjsText1023" font-family="Helvetica" x="90" y="69.3015625" font-size="20" text-anchor="end" family="Helvetica" size="20" anchor="end" svgjs:data="{&quot;leading&quot;:&quot;1.3&quot;}"><tspan id="SvgjsTspan1024" dy="26" x="90" svgjs:data="{&quot;newLined&quot;:true}">   [3:0] </tspan></text><text id="SvgjsText1025" font-family="Helvetica" x="125" y="69.3015625" font-size="20" text-anchor="start" family="Helvetica" size="20" anchor="start" svgjs:data="{&quot;leading&quot;:&quot;1.3&quot;}"><tspan id="SvgjsTspan1026" dy="26" x="125" svgjs:data="{&quot;newLined&quot;:true}">   m1 </tspan></text><line id="SvgjsLine1027" x1="95" y1="90" x2="110" y2="90" stroke-linecap="rec" stroke="black" stroke-width="5"></line><text id="SvgjsText1028" font-family="Helvetica" x="280" y="9.3015625" font-size="20" text-anchor="start" family="Helvetica" size="20" anchor="start" svgjs:data="{&quot;leading&quot;:&quot;1.3&quot;}"><tspan id="SvgjsTspan1029" dy="26" x="280" svgjs:data="{&quot;newLined&quot;:true}">   [3:0] </tspan></text><text id="SvgjsText1030" font-family="Helvetica" x="245" y="9.3015625" font-size="20" text-anchor="end" family="Helvetica" size="20" anchor="end" svgjs:data="{&quot;leading&quot;:&quot;1.3&quot;}"><tspan id="SvgjsTspan1031" dy="26" x="245" svgjs:data="{&quot;newLined&quot;:true}">   b_inv </tspan></text><line id="SvgjsLine1032" x1="260" y1="30" x2="275" y2="30" stroke-linecap="rec" stroke="black" stroke-width="5"></line></svg></p><h2 id="description">Description</h2><div id="teroshdl_description"><p>Copyright lowRISC contributors. Licensed under the Apache License, Version 2.0, see LICENSE for details. SPDX-License-Identifier: Apache-2.0 AES Masked Canright SBox with Mask Re-Use For details, see the following paper: Canright, "A very compact 'perfectly masked' S-box for AES (corrected)" available at <a href="https://eprint.iacr.org/2009/011.pdf">https://eprint.iacr.org/2009/011.pdf</a> Note: This module implements the masked inversion algorithm with re-using masks. For details, see Section 2.3 of the paper. Re-using masks may make the implementation more vulnerable to higher-order differential side-channel analysis, but it remains secure against first-order attacks. This implementation is commonly referred to as THE Canright Masked SBox. A formal analysis using REBECCA (stable and transient mode) shows that this implementation is not secure. It's usage is thus discouraged. It's included here mainly for reference. For details on the REBECCA tool, see the following paper: Bloem, "Formal verification of masked hardware implementations in the presence of glitches" available at <a href="https://eprint.iacr.org/2017/897.pdf">https://eprint.iacr.org/2017/897.pdf</a> IMPORTANT NOTE:                                                                               // DO NOT USE THIS FOR SYNTHESIS BLINDLY!                             // // This implementation relies on primitive cells like prim_buf/xor2 containing tool-specific     // synthesis attributes to enforce the correct ordering of operations and avoid aggressive       // optimization. Without the proper primitives, synthesis tools might heavily optimize the       // design. The result is likely insecure. Use with care.                                         // Masked inverse in GF(2^4), using normal basis [z^4, z] (see Formulas 6, 13, 14, 15, 21, 22, 23, 24 in the paper)</p></div><h2 id="ports">Ports</h2>
<table>
<thead>
<tr>
<th id="port_name">Port name</th>
<th id="direction">Direction</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>b</td>
<td>input</td>
<td>[3:0]</td>
<td></td>
</tr>
<tr>
<td>q</td>
<td>input</td>
<td>[3:0]</td>
<td></td>
</tr>
<tr>
<td>r</td>
<td>input</td>
<td>[1:0]</td>
<td></td>
</tr>
<tr>
<td>m1</td>
<td>input</td>
<td>[3:0]</td>
<td></td>
</tr>
<tr>
<td>b_inv</td>
<td>output</td>
<td>[3:0]</td>
<td></td>
</tr>
</tbody>
</table><h2 id="signals">Signals</h2>
<table>
<thead>
<tr>
<th id="name">Name</th>
<th id="type">Type</th>
<th id="description">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>b1</td>
<td>logic [1:0]</td>
<td></td>
</tr>
<tr>
<td>b0</td>
<td>logic [1:0]</td>
<td></td>
</tr>
<tr>
<td>q1</td>
<td>logic [1:0]</td>
<td></td>
</tr>
<tr>
<td>q0</td>
<td>logic [1:0]</td>
<td></td>
</tr>
<tr>
<td>c_inv</td>
<td>logic [1:0]</td>
<td></td>
</tr>
<tr>
<td>r_sq</td>
<td>logic [1:0]</td>
<td></td>
</tr>
<tr>
<td>m11</td>
<td>logic [1:0]</td>
<td></td>
</tr>
<tr>
<td>m10</td>
<td>logic [1:0]</td>
<td></td>
</tr>
<tr>
<td>mul_b0_q1</td>
<td>logic [1:0]</td>
<td>Get re-usable intermediate results.</td>
</tr>
<tr>
<td>mul_b1_q0</td>
<td>logic [1:0]</td>
<td>Get re-usable intermediate results.</td>
</tr>
<tr>
<td>mul_q1_q0</td>
<td>logic [1:0]</td>
<td>Get re-usable intermediate results.</td>
</tr>
<tr>
<td>mul_b0_q1_buf</td>
<td>logic [1:0]</td>
<td>Avoid aggressive synthesis optimizations.</td>
</tr>
<tr>
<td>mul_b1_q0_buf</td>
<td>logic [1:0]</td>
<td>Avoid aggressive synthesis optimizations.</td>
</tr>
<tr>
<td>mul_q1_q0_buf</td>
<td>logic [1:0]</td>
<td>Avoid aggressive synthesis optimizations.</td>
</tr>
<tr>
<td>scale_omega2_b</td>
<td>logic [1:0]</td>
<td>IMPORTANT: The following ops must be executed in order (left to right): c = r ^ aes_scale_omega2_gf2p2(aes_square_gf2p2(b1 ^ b0)) ^ aes_scale_omega2_gf2p2(aes_square_gf2p2(q1 ^ q0)) ^ aes_mul_gf2p2(b1, b0) ^ mul_b1_q0 ^ mul_b0_q1 ^ mul_q0_q1; Get intermediate terms.</td>
</tr>
<tr>
<td>scale_omega2_q</td>
<td>logic [1:0]</td>
<td>IMPORTANT: The following ops must be executed in order (left to right): c = r ^ aes_scale_omega2_gf2p2(aes_square_gf2p2(b1 ^ b0)) ^ aes_scale_omega2_gf2p2(aes_square_gf2p2(q1 ^ q0)) ^ aes_mul_gf2p2(b1, b0) ^ mul_b1_q0 ^ mul_b0_q1 ^ mul_q0_q1; Get intermediate terms.</td>
</tr>
<tr>
<td>mul_b1_b0</td>
<td>logic [1:0]</td>
<td></td>
</tr>
<tr>
<td>scale_omega2_b_buf</td>
<td>logic [1:0]</td>
<td>These terms are added to other terms that depend on the same inputs. Avoid aggressive synthesis optimizations.</td>
</tr>
<tr>
<td>scale_omega2_q_buf</td>
<td>logic [1:0]</td>
<td>These terms are added to other terms that depend on the same inputs. Avoid aggressive synthesis optimizations.</td>
</tr>
<tr>
<td>mul_b1_b0_buf</td>
<td>logic [1:0]</td>
<td></td>
</tr>
<tr>
<td>c</td>
<td>logic [1:0]</td>
<td>Generate c step by step.</td>
</tr>
<tr>
<td>c_buf</td>
<td>logic [1:0]</td>
<td></td>
</tr>
<tr>
<td>xor_q1_r_sq</td>
<td>logic [1:0]</td>
<td>Re-masking c_inv IMPORTANT: First combine the masks (ops in parens) then apply to c_inv: c_inv  = c_inv ^ (q1 ^ r_sq); c2_inv = c_inv ^ (q0 ^ q1); Get intermediate terms.</td>
</tr>
<tr>
<td>xor_q0_q1</td>
<td>logic [1:0]</td>
<td>Re-masking c_inv IMPORTANT: First combine the masks (ops in parens) then apply to c_inv: c_inv  = c_inv ^ (q1 ^ r_sq); c2_inv = c_inv ^ (q0 ^ q1); Get intermediate terms.</td>
</tr>
<tr>
<td>c1_inv</td>
<td>logic [1:0]</td>
<td>Re-masking c_inv IMPORTANT: First combine the masks (ops in parens) then apply to c_inv: c_inv  = c_inv ^ (q1 ^ r_sq); c2_inv = c_inv ^ (q0 ^ q1); Get intermediate terms.</td>
</tr>
<tr>
<td>c2_inv</td>
<td>logic [1:0]</td>
<td>Re-masking c_inv IMPORTANT: First combine the masks (ops in parens) then apply to c_inv: c_inv  = c_inv ^ (q1 ^ r_sq); c2_inv = c_inv ^ (q0 ^ q1); Get intermediate terms.</td>
</tr>
<tr>
<td>mul_b0_c1_inv</td>
<td>logic [1:0]</td>
<td>IMPORTANT: The following ops must be executed in order (left to right): b1_inv = m11 ^ aes_mul_gf2p2(b0, c1_inv) ^ mul_b0_q1 ^ aes_mul_gf2p2(q0, c1_inv) ^ mul_q0_q1; b0_inv = m10 ^ aes_mul_gf2p2(b1, c2_inv) ^ mul_b1_q0 ^ aes_mul_gf2p2(q1, c2_inv) ^ mul_q0_q1; Get intermediate terms.</td>
</tr>
<tr>
<td>mul_q0_c1_inv</td>
<td>logic [1:0]</td>
<td>IMPORTANT: The following ops must be executed in order (left to right): b1_inv = m11 ^ aes_mul_gf2p2(b0, c1_inv) ^ mul_b0_q1 ^ aes_mul_gf2p2(q0, c1_inv) ^ mul_q0_q1; b0_inv = m10 ^ aes_mul_gf2p2(b1, c2_inv) ^ mul_b1_q0 ^ aes_mul_gf2p2(q1, c2_inv) ^ mul_q0_q1; Get intermediate terms.</td>
</tr>
<tr>
<td>mul_b1_c2_inv</td>
<td>logic [1:0]</td>
<td>IMPORTANT: The following ops must be executed in order (left to right): b1_inv = m11 ^ aes_mul_gf2p2(b0, c1_inv) ^ mul_b0_q1 ^ aes_mul_gf2p2(q0, c1_inv) ^ mul_q0_q1; b0_inv = m10 ^ aes_mul_gf2p2(b1, c2_inv) ^ mul_b1_q0 ^ aes_mul_gf2p2(q1, c2_inv) ^ mul_q0_q1; Get intermediate terms.</td>
</tr>
<tr>
<td>mul_q1_c2_inv</td>
<td>logic [1:0]</td>
<td>IMPORTANT: The following ops must be executed in order (left to right): b1_inv = m11 ^ aes_mul_gf2p2(b0, c1_inv) ^ mul_b0_q1 ^ aes_mul_gf2p2(q0, c1_inv) ^ mul_q0_q1; b0_inv = m10 ^ aes_mul_gf2p2(b1, c2_inv) ^ mul_b1_q0 ^ aes_mul_gf2p2(q1, c2_inv) ^ mul_q0_q1; Get intermediate terms.</td>
</tr>
<tr>
<td>mul_b0_c1_inv_buf</td>
<td>logic [1:0]</td>
<td>The multiplier outputs are added to terms that depend on the same inputs. Avoid aggressive synthesis optimizations.</td>
</tr>
<tr>
<td>mul_q0_c1_inv_buf</td>
<td>logic [1:0]</td>
<td>The multiplier outputs are added to terms that depend on the same inputs. Avoid aggressive synthesis optimizations.</td>
</tr>
<tr>
<td>mul_b1_c2_inv_buf</td>
<td>logic [1:0]</td>
<td>The multiplier outputs are added to terms that depend on the same inputs. Avoid aggressive synthesis optimizations.</td>
</tr>
<tr>
<td>mul_q1_c2_inv_buf</td>
<td>logic [1:0]</td>
<td>The multiplier outputs are added to terms that depend on the same inputs. Avoid aggressive synthesis optimizations.</td>
</tr>
<tr>
<td>b1_inv</td>
<td>logic [1:0]</td>
<td>Generate b1_inv and b0_inv step by step.</td>
</tr>
<tr>
<td>b1_inv_buf</td>
<td>logic [1:0]</td>
<td></td>
</tr>
<tr>
<td>b0_inv</td>
<td>logic [1:0]</td>
<td></td>
</tr>
<tr>
<td>b0_inv_buf</td>
<td>logic [1:0]</td>
<td></td>
</tr>
</tbody>
</table><h2 id="instantiations">Instantiations</h2>
<ul>
<li><p>u_prim_buf_mul_bq01: prim_buf</p></li>
<li><p>u_prim_buf_scale_omega2_bq: prim_buf</p></li>
<li><p>u_prim_buf_mul_b1_b0: prim_buf</p></li>
<li><p>u_prim_xor_q1_r_sq: prim_xor2</p></li>
<li><p>u_prim_xor_q0_q1: prim_xor2</p></li>
<li><p>u_prim_c1_inv: prim_xor2<br />
<strong>Description</strong><br />
Generate c1_inv and c2_inv.</p></li>
<li><p>u_prim_c2_inv: prim_xor2</p></li>
<li><p>u_prim_buf_mul_bq01_c12_inv: prim_buf</p></li>
</ul><br><br><br><br><br><br>